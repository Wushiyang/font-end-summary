# node简介

### 事件驱动编程

##### 早期I/O阻塞编程

早期I/O操作阻塞式编程处理程序需等待某个操作结束继承自早期分时系统，作用是隔离用户，但是管理众多进程就处理慢，性能下降

##### 非协同多线程（异步多线程？）

多线程不知道给定时刻哪些线程执行，要仔细处理共享内存状态的并发访问，使用如线程锁和信号量的同步原语协调某些数据结构访问，强制它们对线程执行调度的各种途径进行预测以避免问题发生，如程序非常依赖线程间共享状态，那么这种编程方式容易导致随机发生的危险错误，难以排查。（修改共享状态影响到其他线程导致难以排查？）

##### 事件驱动编程

事件驱动编程是创建处理众多并发连接的服务的最佳方法：由于不用保存很多上下文，因此节省大量内存；又因为没那么多上下文切换，又节省大量执行事件。

使用事件驱动编程要避免使用同步库，这会使事件循环经常被阻塞，妨碍处理I/O事件

事件驱动编程或异步编程是node的显著特点，处理多个I/O操作不会阻塞，多个I/O操作可以并行进行，每个操作结束将会分别调用对应回调函数。与之相伴的是时间循环，主要具备事件检测和事件触发处理

```伪代码
//isRun()主线程程序是否启动
while(isRun()){
	//是否触发事件
	if(isTriggerEvent()){
		//处理事件，如果有I/O操作，则开一个线程处理I/O操作，在回调里做其他操作，主线程继续运行
		excuteEvent(callback())
	}
}
```

特点：

1、任一给定时刻最多运行一个事件处理程序

2、事件处理程序可以不间断运行



### 闭包和异步编程

JavaScript是函数作用域，可通过创建函数的形式创建闭包A，闭包A内代码可访问父作用域B，即使父作用域B已经返回结束清理内存，此时被闭包A调用的父作用域B的变量不会被清理仍会留在内存。

JavaScript的闭包机制对事件驱动编程有两个好处：

1、状态变量可传递给函数而不用维护它状态就能进行事件驱动编程

2、JavaScript闭包会为你维护状态

```javascript
函数执行结束后share变量仍保留在内存，供onTrigger1和onTrigger2的回调函数调用，share变量被onTrigger1和onTrigger2共享
let share = 0
app.onTrigger1(function(){
    share++
})
app.onTrigger2(function(){
    share--
})
详例./例子/闭包/closure.js
```

概念：

第一类函数：可以在执行期创造并作为参数传递给其他函数或存入变量的函数

JavaScript具有第一类函数和闭包

